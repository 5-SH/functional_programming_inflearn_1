<script src="../lib/fx.js"></script>

## QnA 비동기는 async/await 로 제어할 수 있는데 왜 파이프라인이 필요한지
<script>
  async function delayI(a) {
    return new Promise(resolve => setTimeout(() => resolve(a), 100));
  }

  /**
   * async/await 가 해결하려는 문제와 파이프라인, 체인이 해결하려는 문제는 다르다.
   * async/await 
   *  -> promise.then().then().then()... 비동기 함수 체인을 문장으로 다루기 위해 사용.
   *    합성하는 것이 아니라 풀기 위한 것.
   * 파이프라인
   *  -> 비동기 프로그래밍이 아니라 함수 합성이 목적.
   *    명령형 프로그래밍을 하지 않고 안전하게 합수 합성하기 위해 사용.
   *    비동기, 동기 상황 보다 어떤 코드를 리스트로 다루며 연속적인 함수 실행과
   *    함수 합성을 통해 더 효과적으로 함수들을 조합하고 로직을 테스트하기 쉽고
   *    유지보수하기 쉽게 만드는데 목적이 있음.
   * 
   */

  // 선언형 프로그래밍
  function f5(list) {
    return go(list,
      L.map(a => delayI(a * a)),
      L.filter(a => delayI(a % 2)),
      L.map(a => delayI(a + 1)),
      take(3),
      reduce((a, b) => delayI(a + b)));
  };
  go(f5([1, 2, 3, 4, 5, 6, 7, 8]), log);

  /** 
   * 명령형 프로그래밍, 비동기 상황을 async/await 로 문장으로 풀어서 사용한다.
   * delayI 함수가 비동기가 아니면 f5 함수는 변함없이 정상 동작하지만 f6 는 동작하지 않는다.
   * 즉, f6 함수는 f5 함수와 해결하려는 대상이 다르다.
   */ 
  async function f6(list) {
    let temp = [];
    for (const a of list) {
      const b = await delayI(a * a);
      if (await delayI(b % 2)) {
        const c = await delayI(b + 1);
        temp.push(c);
        if (temp.length == 3) break;
      }
    }
    let res = temp[0], i = 0;
    while (++i < temp.length) {
      res = await delayI(res + temp[i]);
    }
    return res;
  }
  go(f6([1, 2, 3, 4, 5, 6, 7, 8]), log)
</script>
